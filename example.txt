// add second node
	if len(t.Nodes) == 1 { // adding second node then his parent
		depth = len(t.Nodes) + 1
		updateNodesIndex(t, depth)
		hash, err := cs.CalculateHash()
		if err != nil {
			return nil, err
		}
		x := integerToBinaryString(1, 2) // "01"
		newNode := &Node{
			Hash:   hash,
			C:      cs,
			data:   cs.Data(),
			leaf:   true,
			Tree:   t,
			Number: 2,
			Index:  x,
			done:   true,
		}
		t.Nodes = append(t.Nodes, newNode)
		t.Levels[2] = append(t.Levels[2], newNode)
		fmt.Println("added second node:", cs.Data())
		updateLevelsEntry(t)

		//addnig parent upper
		newX := integerToBinaryString(0, 1) // "0"
		newContentString := t.Nodes[0].data + t.Nodes[1].data
		newcontent := NewContent{x: newContentString}
		newRootHash, err := newcontent.CalculateHash()
		if err != nil {
			return nil, err
		}

		newRootNode := &Node{
			Hash:   newRootHash,
			C:      newcontent,
			data:   newcontent.Data(),
			leaf:   false,
			Tree:   t,
			Number: 3,
			Index:  newX,
			done:   false,
			Left:   t.Nodes[0],
			Right:  t.Nodes[1],
		}
		t.Nodes = append(t.Nodes, newRootNode)
		t.Levels[1] = append(t.Levels[1], newRootNode)
		fmt.Println("added upper node:", newcontent.Data())
		updateLevelsEntry(t)
		return t.Root, nil
	}

	// navigate Tree Nodes to add new nodes (N is all of tree nodes count)
	i := len(t.Nodes)
	traversingNumber := i + 1
	beforeNode := t.Nodes[i-1]
	depth = int(math.Log2(float64(len(t.Nodes) + 2)))
	updateNodesIndex(t, depth)
	x := beforeNode.Index[:len(beforeNode.Index)-1]
	if beforeNode.leaf == true && countLeafs(t)%2 == 1 { // beforenode is leaf and nodes are odd - added as new leaf
		fmt.Println("1- if: beforenode is leaf and nodes are odd - added as new leaf:", cs.Data())
		depth = int(math.Log2(float64(len(t.Nodes) + 2)))
		updateNodesIndex(t, depth)
		updateLevelsEntry(t)
		hash, err := cs.CalculateHash()
		if err != nil {
			return nil, err
		}
		x := integerToBinaryString(countLeafs(t), depth)
		newNode := &Node{
			Hash:   hash,
			C:      cs,
			data:   cs.Data(),
			leaf:   true,
			Tree:   t,
			Number: traversingNumber,
			Index:  x,
			done:   true,
		}
		t.Nodes = append(t.Nodes, newNode)
		t.Levels[depth] = append(t.Levels[depth], newNode)
		setParentsToNode(newNode, t)

		// add new upper
		depth = int(math.Log2(float64(len(t.Nodes) + 2)))
		newX := integerToBinaryString(len(t.Levels[depth-1]), depth-1)
		newContentString := beforeNode.data + newNode.data
		newcontent := NewContent{x: newContentString}
		newNumber := len(t.Nodes) + 1
		newRootHash, err := newcontent.CalculateHash()
		if err != nil {
			return nil, err
		}
		newRootNode := &Node{
			Hash:   newRootHash,
			C:      newcontent,
			data:   newcontent.Data(),
			leaf:   false,
			Tree:   t,
			Number: newNumber,
			Index:  newX,
			done:   false,
			Left:   beforeNode,
			Right:  newNode,
		}
		t.Nodes = append(t.Nodes, newRootNode)
		updateLevelsEntry(t)
		// t.Levels[depth-1] = append(t.Levels[depth-1], newRootNode)
		fmt.Println("6- added new upper node:", newcontent.Data())

		if t.Nodes[len(t.Nodes)-1].leaf == false {
			beforeNodeIndex := t.Nodes[len(t.Nodes)-1].Index
			beforeNodeLevel := len(beforeNodeIndex)
			countBeforeLevel := len(t.Levels[beforeNodeLevel])
			fmt.Println(beforeNodeIndex)
			if countBeforeLevel%2 == 0 {
				depth = int(math.Log2(float64(len(t.Nodes) + 2)))
				updateNodesIndex(t, depth)
				updateLevelsEntry(t)
				rightNode := t.Nodes[len(t.Nodes)-1]
				leftIndexLength := len(t.Nodes[len(t.Nodes)-1].Index)
				leftNodei := len(t.Levels[leftIndexLength])
				leftNode := t.Levels[leftIndexLength][leftNodei-2]

				levelnum := depth - len(t.Nodes[len(t.Nodes)-1].Index)
				newX := integerToBinaryString(len(t.Levels[levelnum]), levelnum)
				newContentString := leftNode.data + rightNode.data
				newcontent := NewContent{x: newContentString}
				newNumber := len(t.Nodes) + 1
				newRootHash, err := newcontent.CalculateHash()
				if err != nil {
					return nil, err
				}
				newRootNode := &Node{
					Hash:   newRootHash,
					C:      newcontent,
					data:   newcontent.Data(),
					leaf:   false,
					Tree:   t,
					Number: newNumber,
					Index:  newX,
					done:   false,
				}
				t.Nodes = append(t.Nodes, newRootNode)
				levelnum = depth - len(t.Nodes[len(t.Nodes)-1].Index)
				t.Levels[levelnum-1] = append(t.Levels[levelnum-1], newRootNode)
				fmt.Println("7- added new upper node:", newcontent.Data())
				return t.Root, nil

			} else if countBeforeLevel%2 != 0 {
				if t.Nodes[len(t.Nodes)-1].Number == int(math.Pow(2, float64(depth)))-1 {
					leftNode := t.Levels[1][0]
					depth = int(math.Log2(float64(len(t.Nodes) + 2)))

					updateNodesIndex(t, depth)
					updateLevelsEntry(t)
					rightNode := t.Nodes[len(t.Nodes)-1]
					fmt.Println(len(t.Nodes[len(t.Nodes)-1].Index), t.Nodes[len(t.Nodes)-1].data)

					levelnum := depth - len(t.Nodes[len(t.Nodes)-1].Index)
					newX := integerToBinaryString(len(t.Levels[levelnum-1]), levelnum-1)
					newContentString := leftNode.data + rightNode.data
					newcontent := NewContent{x: newContentString}
					newNumber := len(t.Nodes) + 1
					newRootHash, err := newcontent.CalculateHash()
					if err != nil {
						return nil, err
					}
					newRootNode := &Node{
						Hash:   newRootHash,
						C:      newcontent,
						data:   newcontent.Data(),
						leaf:   false,
						Tree:   t,
						Number: newNumber,
						Index:  newX,
						done:   false,
					}
					t.Nodes = append(t.Nodes, newRootNode)
					fmt.Println("last index:", t.Nodes[len(t.Nodes)-1].Index, t.Nodes[len(t.Nodes)-1].data)
					levelnum = len(t.Nodes[len(t.Nodes)-1].Index)
					t.Levels[levelnum] = append(t.Levels[levelnum], newRootNode)
					fmt.Println("8- added new upper node:", newcontent.Data())
					return t.Root, t.Nodes, nil
				} else if len(t.Nodes[len(t.Nodes)-1].Index) == depth-1 {
					depth = int(math.Log2(float64(len(t.Nodes) + 2)))
					updateNodesIndex(t, depth)
					updateLevelsEntry(t)

					levelnum := len(t.Nodes[len(t.Nodes)-1].Index)
					newcontent := NewContent{x: newContentString}
					newNumber := len(t.Nodes) + 1
					newRootHash, err := newcontent.CalculateHash()
					if err != nil {
						return nil, err
					}
					newRootNode := &Node{
						Hash:   newRootHash,
						C:      cs,
						data:   newcontent.Data(),
						leaf:   true,
						Tree:   t,
						Number: newNumber,
						Index:  newX,
						done:   false,
					}
					t.Nodes = append(t.Nodes, newRootNode)
					fmt.Println("last index:", t.Nodes[len(t.Nodes)-1].Index, t.Nodes[len(t.Nodes)-1].data)
					levelnum = len(t.Nodes[len(t.Nodes)-1].Index)
					t.Levels[levelnum] = append(t.Levels[levelnum], newRootNode)
					fmt.Println("9- added new leaf node:", newcontent.Data())
					return t.Root, nil
				}

			}
		}

		return t.Root, nil
	} else if beforeNode.leaf == true && countLeafs(t)%2 == 0 { //beforenode is leaf and leafs are even -  added as parent node
		fmt.Println("2- if: beforenode is leaf and leafs are even -  added as parent node:", cs.Data())
		depth = int(math.Log2(float64(len(t.Nodes) + 2)))
		updateNodesIndex(t, depth)
		hash, err := cs.CalculateHash()
		if err != nil {
			return nil, err
		}
		x := beforeNode.Index[:len(beforeNode.Index)-1]
		newNode := &Node{
			Hash:   hash,
			C:      cs,
			data:   cs.Data(),
			leaf:   false,
			Tree:   t,
			Number: traversingNumber,
			Index:  x,
			Left:   t.Nodes[i-2],
			Right:  t.Nodes[i-1],
		}
		t.Nodes = append(t.Nodes, newNode)
		updateLevelsEntry(t)
		t.Levels[len(x)] = append(t.Levels[len(x)], newNode)
		t.Nodes[1].Parents = append(t.Nodes[1].Parents, newNode)
		return t.Root, nil
	} else if beforeNode.leaf == false && len(t.Levels[len(t.Nodes[len(t.Nodes)-1].Index)])%2 == 0 { // before node is a parent and new node will upper node of them
		fmt.Println("3- if: before node is a parent and new node will upper node of them:", cs.Data())

		fmt.Println("Hiiiiiii:", t.Levels[1])
		depth = int(math.Log2(float64(len(t.Nodes) + 2)))
		updateNodesIndex(t, depth)
		beforeNode := t.Nodes[len(t.Nodes)-1]
		hash, err := cs.CalculateHash()
		if err != nil {
			return nil, err
		}
		x := beforeNode.Index[:len(beforeNode.Index)-1]
		// leftLevelEntry := t.Levels[len(beforeNode.Index)][len(beforeNode.Index)-2]
		newNode := &Node{
			Hash:   hash,
			C:      cs,
			data:   cs.Data(),
			leaf:   false,
			Tree:   t,
			Number: traversingNumber,
			Index:  x,
			Right:  t.Nodes[i-1],
			// Left:   leftLevelEntry,
		}
		t.Nodes = append(t.Nodes, newNode)
		t.Levels[len(x)] = append(t.Levels[len(x)], newNode)
		updateLevelsEntry(t)
		return t.Root, nil
	} else if beforeNode.leaf == false && len(t.Levels[len(beforeNode.Index)])%2 != 0 { // before node is a parent up to the leafs. so new node will be leaf
		fmt.Println("4- if: before node is a parent up to the leafs. so new node will be leaf:", cs.Data())
		depth = int(math.Log2(float64(len(t.Nodes) + 2)))
		updateNodesIndex(t, depth)
		hash, err := cs.CalculateHash()
		if err != nil {
			return nil, err
		}

		x := integerToBinaryString(countLeafs(t), depth)
		newNumber := len(t.Nodes) + 1
		newNode := &Node{
			Hash:   hash,
			C:      cs,
			data:   cs.Data(),
			leaf:   true,
			Tree:   t,
			Number: newNumber,
			Index:  x,
		}
		t.Nodes = append(t.Nodes, newNode)
		t.Levels[len(x)] = append(t.Levels[len(x)], newNode)
		setParentsToNode(newNode, t)
		updateLevelsEntry(t)
		return t.Root, nil
	} else if beforeNode.leaf == false && len(t.Levels[len(beforeNode.Index)])%2 != 0 { // before node is a parent and new node will upper node of them
		fmt.Println("5- if: before node is a parent and new node will upper node of them", cs.Data())
		depth = int(math.Log2(float64(len(t.Nodes) + 1)))
		updateNodesIndex(t, depth)
		hash, err := cs.CalculateHash()
		if err != nil {
			return nil, err
		}
		// x := beforeNode.Index[:len(beforeNode.Index)-1]
		// leftLevelEntry := t.Levels[len(beforeNode.Index)][len(beforeNode.Index)]

		newNode := &Node{
			Hash:   hash,
			C:      cs,
			data:   cs.Data(),
			leaf:   true,
			Tree:   t,
			Number: traversingNumber,
			Index:  x,
			Right:  t.Nodes[i-1],
			// Left:   leftLevelEntry,
		}
		t.Nodes = append(t.Nodes, newNode)
		t.Levels[len(x)] = append(t.Levels[len(x)], newNode)
		updateLevelsEntry(t)
		return t.Root, nil
	}
	return nil, nil



    func printLevels(t *PoSW_DAG) {
	for i := 0; i < len(t.Levels); i++ {
		fmt.Printf("Level %d counted nodes are: %d\n", i, len(t.Levels[i]))
		for t, j := range t.Levels[i] {

			fmt.Println(t, j)
		}
	}
}

func printLevel(t *PoSW_DAG, level int) {
	fmt.Printf("Level %d counted nodes are: %d\n", level, len(t.Levels[level]))
	for t, j := range t.Levels[level] {

		fmt.Println(t, j)
	}
}
